# Ranqueamento de documentos 

[![Linguagem C++](https://img.shields.io/badge/Linguagem-C%2B%2B-green.svg)](https://github.com/TFIDF-Project)
[![requirement](https://img.shields.io/badge/IDE-Visual%20Studio%20Code-informational)](https://code.visualstudio.com/docs/?dv=linux64_deb)
![ISO](https://img.shields.io/badge/ISO-Linux-blueviolet)


<h1> Algoritmo TF/IDF

## Conte√∫dos

<p align="center">
 <a href="#-apresenta√ß√£o">Apresenta√ß√£o</a> ‚Ä¢
 <a href="#-algoritmo-tf-idf">Algoritmo TF-IDF</a> ‚Ä¢
 <a href="#%EF%B8%8F-como-o-c√°lculo-√©-usado-pelo-google">Como o c√°lculo √© usado pelo Google?</a> ‚Ä¢
 <a href="#-l√≥gica">L√≥gica</a> ‚Ä¢
 <a href="#-stopwords-e-sua-implementa√ß√£o">Stopwords e sua implementa√ß√£o</a> ‚Ä¢
 <a href="#-l√≥gica-do-ranqueamento-de-documentos-e-do-c√°lculo-tf-idf">L√≥gica do ranqueamento e do c√°lculo TF-IDF</a> ‚Ä¢
 <a href="#%EF%B8%8F-fun√ß√µes">Fun√ß√µes</a> ‚Ä¢
 <a href="#-representa√ß√£o-gr√°fica">Representa√ß√£o gr√°fica</a> ‚Ä¢
 <a href="#-execu√ß√£o-de-testes">Execu√ß√£o de testes</a> ‚Ä¢ 
 <a href="#-bibliotecas">Bibliotecas</a> ‚Ä¢
 <a href="#-compila√ß√£o-e-execu√ß√£o">Compila√ß√£o e Execu√ß√£o</a> ‚Ä¢ 
 <a href="#%EF%B8%8F-autores">Autores</a>
</p>

---

## üöÄ Apresenta√ß√£o

Foi proposto pelo professor [Michel Pires da Silva](http://lattes.cnpq.br/1449902596670082) da mat√©ria de Arquitetura e Estruturas de Dados 1 do curso de Engenharia da Computa√ß√£o um trabalho onde o objetivo √© projetar uma estrutura de filtragem de documentos por ranqueamento de palavras tendo como base o <a href="#algoritmo-tf-idf">Algoritmo TF-IDF</a>, estrutura que j√° foi utilizada pelo algor√≠tmo do Google no √≠nicio. Para ser validado √† corre√ß√£o, o trabalho deve seguir os seguintes pr√©-requisitos:
  - [X] O c√≥digo deve ser elaborado utilizando as linguagens <b>C</b> ou <b>C++</b>
  - [X] Exibir os documentos devidamente ranqueados
  - [X] O programa deve ser capaz de calcular o tempo de execu√ß√£o
  - [X] O c√≥digo deve ser implementado de forma que vise o menor custo computacional poss√≠vel
  - [X] O c√≥digo deve utilizar algum dos tipos abstratos de estrutura de dados apresentados em sala

---

### üë®‚Äçüíª Algoritmo TF-IDF

TF-IDF √© um c√°lculo usado pelo Google para entender a import√¢ncia dos termos nas p√°ginas de um site. Conhecer esse modelo ajuda a entender o buscador, mas tamb√©m a planejar e otimizar seus conte√∫dos. Essa sigla, TF-IDF, representa uma forma do Google determinar estatisticamente a import√¢ncia de uma palavra-chave ou uma frase analisando centenas ou milhares de documentos.

<h4>O que √© o TF-IDF?</h4>

<strong>TF-IDF</strong> significa <strong>Term Frequency ‚Äì Inverse Document Frequency</strong>. Essa express√£o pode ser traduzida para o portugu√™s como <strong>‚ÄúFrequ√™ncia do Termo ‚Äì Frequ√™ncia Inversa dos Documentos‚Äù</strong>, que √© um c√°lculo estat√≠stico adotado pelo algoritmo do Google para medir quais termos s√£o mais relevantes para um t√≥pico, analisando a frequ√™ncia com que aparecem em uma p√°gina, em compara√ß√£o √† sua frequ√™ncia em um conjunto maior de p√°ginas. O c√°lculo serve como fator de pondera√ß√£o de termos, ou seja, para entender a import√¢ncia de um termo ou frase espec√≠fica para determinado documento.

<strong>TF</strong> se refere √† <strong>‚Äúfrequ√™ncia do termo‚Äù</strong>. Essa parte do c√°lculo responde √† pergunta: com que frequ√™ncia o termo aparece nesse documento? <strong>Quanto maior for a frequ√™ncia no documento, maior ser√° a import√¢ncia do termo</strong>.

<strong>IDF</strong> significa <strong>‚Äúfrequ√™ncia inversa dos documentos‚Äù</strong>. Nessa parte, a ferramenta responde: com que frequ√™ncia o termo aparece em todos os documentos da cole√ß√£o? <strong>Quanto maior for a frequ√™ncia nos documentos, menor ser√° a import√¢ncia do termo</strong>.

<h4>Como √© calculado?</h4>

<ul>
  <li>
    <strong>TF: Term Frequency</strong>, mede a frequ√™ncia com que um termo ocorre em um documento. Como cada documento √© diferente em tamanho, √© poss√≠vel que um termo apare√ßa muito mais vezes em documentos longos do que em documentos mais curtos. Assim, a frequ√™ncia do termo √© frequentemente dividida pelo comprimento do documento, ou seja, a frequ√™ncia do termo √© frequentemente dividida pelo n√∫mero total de termos no documento como forma de normaliza√ß√£o:
    
  $$TF(t) = \frac{x}{y}$$
    
  <i>x= N√∫mero de vezes que o termo <i>t</i> aparece em um documento</i><br>
  <i>y = N√∫mero total de termos no documento</i> <br><br>
  </li>
  
  <li>
    <strong>IDF: Inverse Document Frequency</strong>, mede a import√¢ncia de um termo. Ao calcular o TF, todos os termos s√£o considerados igualmente importantes. No entanto, sabe-se que certos termos, como ‚Äú√©‚Äù, ‚Äúde‚Äù e ‚Äúisso‚Äù, podem aparecer muitas vezes, mas t√™m pouca import√¢ncia. Assim, precisamos pesar os termos frequentes enquanto escalamos os raros, calculando o seguinte:
    
  $$IDF(t) = log{(\frac{w}{z})}$$
    
  <i>w = N√∫mero total de documentos</i><br>
  <i>z = N√∫mero de documentos com termo t nele</i><br><br>
  </li>
</ul>

Podemos resumir assim, que a import√¢ncia do termo aumenta conforme o n√∫mero de vezes que a palavra aparece no documento, mas √© compensada pelo n√∫mero de repeti√ß√µes na cole√ß√£o de documentos, o que serve para ajustar o fato de que algumas palavras aparecem com mais frequ√™ncia em geral.

### üñ•Ô∏è Como o c√°lculo √© usado pelo Google?

O c√°lculo TF-IDF √© um exemplo da tecnologia incorporada ao rob√¥ para processamento de linguagem. O Google adota sistemas que fazem esses c√°lculos automaticamente em milh√µes de documentos da web para dar sentido ao que eles est√£o dizendo.

TF-IDF √© usado como parte da indexa√ß√£o sem√¢ntica latente (LSI ou Latent Semantic Indexing). O Google utiliza essa abordagem de indexa√ß√£o para compreender as rela√ß√µes entre palavras, frases e conceitos, ou seja, a sem√¢ntica dos textos de um site. Isso √© essencialmente importante quando h√° palavras com significados semelhantes ou com mais de um significado.

Dentro dessa l√≥gica, ent√£o, o TF-IDF serve para processar a linguagem utilizada nos conte√∫dos. Ele n√£o serve para dar sentido aos termos, mas para entender a sua import√¢ncia ao dar pesos diferentes para eles.

Resumindo, o TF-IDF ajusta esse c√°lculo para compreender a import√¢ncia do termo ao comparar a frequ√™ncia na p√°gina com a sua frequ√™ncia em outros milhares de documentos. Dessa forma, o Google consegue refinar a qualidade da indexa√ß√£o para as palavras-chave corretas.

---

## üì¶ L√≥gica

O algoritmo do c√°lculo TF-IDF criado pelo nosso grupo utilizou de base a `Estruturas de Dados do Tipo Lista Din√¢mica` pela suas vantagens onde o seu custo e tratamento s√£o melhores que outras **Estruturas de Dados** j√° estudadas at√© o momento no curso de `Engenharia da Computa√ß√£o`, visto tamb√©m que em aplica√ß√µes em que n√£o existe previs√£o sobre o crescimento da lista, √© conveniente usar _listas din√¢micas_, onde permite utilizar posi√ß√µes n√£o cont√≠guas de mem√≥ria sendo poss√≠vel **inserir** e **retirar** elementos sem haver necessidade de deslocar os itens seguintes da lista e em um custo constante.
Uma das principais ideias pensadas pelo grupo ao otimizar o algoritmo e reduzir o seu custo que ao nosso ver tamb√©m difere da ideia principal dos outros grupos √© o **tratamento das _stopwords_**, onde inicialmente seria a parte em que o custo computacional do programa seria maior por precisar de diversos tratamentos, com isso foi pensado ent√£o na l√≥gica e implementa√ß√£o presente no t√≥pico abaixo:

---

### üìã Stopwords e sua implementa√ß√£o

Foi criado um arquivo contendo todas as <i>stopwords</i> em portugu√™s, que √© derivada das <i>stopwords</i> em ingl√™s do Natural Language Toolkit, comumente chamado de NLTK, que √© um conjunto de bibliotecas e programas para processamento simb√≥lico e estat√≠stico da linguagem natural para ingl√™s. A partir das <i>stopwords</i> do NLKT foi feita a tradu√ß√£o das poss√≠veis <i>stopwords</i> para o portugu√™s, dando resultado ao arquivo de texto <code>stopwords.txt</code>.

### Leitura das <i>stopwords</i>

Depois da cria√ß√£o do arquivo contendo todas as <i>stopwords</i>, foi feita a implementa√ß√£o de uma fun√ß√£o para que seja feita a leitura do arquivo e que essa fun√ß√£o separe e insira palavra por palavra em uma estrutura de lista din√¢mica. 

### <i>Mas por que uma estrutura de lista din√¢mica?</i>

Nesse caso, usamos a lista din√¢mica por ser de maior facilidade de uso, mas caso us√°ssemos estrutura de pilha ou fila, a fun√ß√£o teria a mesma finalidade que √© de armazenar as <i>stopwords</i> e n√£o haveria mudan√ßa alguma quanto a custo computacional, j√° que seria feito apenas a inser√ß√£o das <i>stopwords</i> primeiramente.



### A fun√ß√£o citada √© a seguinte:

<ul>
	<li><i>list.hpp</i></li>
</ul>

```c++
	void filter_stop_words(List *lw1, List *lw2, List *lw3, List *lw4, List *lw5, List *lw6, List *lw7, List *lw8, List *lw9, List *lw10, List *lw11, List *lw12, List *lw13, Item d);
```
<ul>
	<li><i>list.cpp</i></li>
</ul>

```c++
	void filter_stop_words(List *lw1, List *lw2, List *lw3, List *lw4, List *lw5, List *lw6, List *lw7, List *lw8, List *lw9, List *lw10, List *lw11, List *lw12, List *lw13, Item d){
	FLVazia(lw1);
	FLVazia(lw2);
	FLVazia(lw3);
	FLVazia(lw4);
	FLVazia(lw5);
	FLVazia(lw6);
	FLVazia(lw7);
	FLVazia(lw8);
	FLVazia(lw9);
	FLVazia(lw10);
	FLVazia(lw11);
	FLVazia(lw12);
	FLVazia(lw13);

	string line;
	ifstream my_file;
	int numberCaracters;

	my_file.open("stopwords.txt");

	if(my_file.is_open()){
		while(! my_file.eof()){
			getline(my_file, line);
			d.word = line;
			numberCaracters = line.length(); //Contagem do n√∫mero de caracteres das stopwords.

			//Se a palavra ter 1 caractere, ser√° inserida na Lista lw1.
			if(numberCaracters == 2){
				LInsert(lw1, d);
			}
			//Se a palavra ter 2 caracteres, ser√° inserida na Lista lw2.
			else if(numberCaracters == 3){
				LInsert(lw2, d);
			}
			//Se a palavra ter 3 caracteres, ser√° inserida na Lista lw3.
			else if(numberCaracters == 4){
				LInsert(lw3, d);
			}
			//Se a palavra ter 4 caracteres, ser√° inserida na Lista lw4.
			else if(numberCaracters == 5){
				LInsert(lw4, d);
			}
			//Se a palavra ter 5 caracteres, ser√° inserida na Lista lw5.
			else if(numberCaracters == 6){
				LInsert(lw5, d);
			}
			//Se a palavra ter 6 caracteres, ser√° inserida na Lista lw6.
			else if(numberCaracters == 7){
				LInsert(lw6, d);
			}
			//Se a palavra ter 7 caracteres, ser√° inserida na Lista lw7.
			else if(numberCaracters == 8){
				LInsert(lw7, d);
			}
			//Se a palavra ter 8 caracteres, ser√° inserida na Lista lw8.
			else if(numberCaracters == 9){
				LInsert(lw8, d);
			}
			//Se a palavra ter 9 caracteres, ser√° inserida na Lista lw9.
			else if(numberCaracters == 10){
				LInsert(lw9, d);
			}
			//Se a palavra ter 10 caracteres, ser√° inserida na Lista lw10.
			else if(numberCaracters == 11){
				LInsert(lw10, d);
			}
			//Se a palavra ter 11 caracteres, ser√° inserida na Lista lw11.
			else if(numberCaracters == 12){
				LInsert(lw11, d);
			}
			//Se a palavra ter 12 caracteres, ser√° inserida na Lista lw12.
			else if(numberCaracters == 13){
				LInsert(lw12, d);
			}
			//Se a palavra ter 13 caracteres, ser√° inserida na Lista lw13.
			else if(numberCaracters == 14){
				LInsert(lw13, d);
			}
		}
		my_file.close(); //Fecha o arquivo de texto.
		cout << "\n";
	}

	else{
		cout << "Arquivo n√£o abriu.\n";
	} 
}
```

### An√°lise

Foi analisado nas <i>stopwords</i> padr√µes em portugu√™s que as mesmas possuem de 1 a 13 caracteres, ent√£o a fim de diminuir o custo computacional de compara√ß√µes das palavras encontradas nos documentos com as <i>stopwords</i>, foram criadas 13 listas diferentes, cada uma representando palavras com uma quantidade de caracteres que varia de 1 a 13 como dito anteriormente.

Ap√≥s a cria√ß√£o das listas, vamos para a leitura do arquivo das <i>stopwords</i>, onde o par√¢metro para a separa√ß√£o das palavras √© a quebra de linha ou o caractere <code>\n</code>, ou seja, √© feita a leitura do arquivo linha por linha at√© que a leitura chegue ao final do arquivo. Mas no meio desta leitura foram criadas 13 condi√ß√µes de inser√ß√£o de <i>stopwords</i> √† listas din√¢micas. 

<strong>Exemplo para explica√ß√£o:</strong>

```c++
	if(my_file.is_open()){
		while(! my_file.eof()){
			getline(my_file, line);
			d.word = line;
			numberCaracters = line.length();

			if(numberCaracters == 2){
				LInsert(lw1, d);
			}
		}
		
		my_file.close(); 
	}
	
	else{
		cout << "Arquivo n√£o abriu.\n";
	} 
	
```

<ol>
	<li><code>if(my_file.is_open())</code> : Cria a condi√ß√£o que, se o arquivo com nome salvo na vari√°vel <i>my_file</i> abrir, executa o que est√° contido dentro da condi√ß√£o.</li>
	<li><code>while(! my_file.eof())</code> : La√ßo de repeti√ß√£o que s√≥ finaliza quando a leitura do arquivo chegar ao final do arquivo.</li>
	<li><code>getline(my_file, line)</code> : Armazena o que est√° contido naquela linha no momento do la√ßo de repeti√ß√£o na vari√°vel <code>line</code>.</li>
	<li><code>d.word = line</code> : <code>d</code> √© uma <i>struct</i> que cont√©m em seu interior uma <i>string</i> chamada <code>word</code>, ent√£o √† <code>d.word</code> √© feita a atribui√ß√£o de <code>line</code>.</li>
	<li><code>numberCaracters = line.length()</code> : <code>numberCaracters</code> √© a vari√°vel que ir√° armazenar o n√∫mero de caracteres de <code>line</code>, onde foi feita a contagem pela fun√ß√£o <code>length()</code>, por isso <code>line.length()</code>.</li>
</ol>

A partir daqui s√£o criadas as condi√ß√µes baseadas no tamanho da vari√°vel <code>numberCaracters</code> para a inser√ß√£o nas listas din√¢micas. Exemplo de condi√ß√£o:

```c++
	if(numberCaracters == 2){
		LInsert(lw1, d);
	}
```

A condi√ß√£o acima analisa se a vari√°vel <code>numberCaracters</code> √© igual a 2, e se for, ela faz a inser√ß√£o da <i>struct</i> <code>d</code> √† lista din√¢mica <code>lw1</code>.

### Observa√ß√µes sobre o c√≥digo apresentado

<ul>
	<li>Nas condi√ß√µes de inser√ß√£o √† lista, para as <i>stopwords</i> de <i>x</i> caracteres a condi√ß√£o √© valida para quando <code>numberCaracters</code> for igual a <i>x + 1</i> porque na leitura do arquivo, o caractere <code>/0</code> ao final da linha √© contado tamb√©m.</li>
	<li>Foi feita a separa√ß√£o das stopwords em 13 diferentes listas din√¢micas a fim de diminuir o custo computacional de compara√ß√£o com as palavras dos documentos  posteriormente, fazendo a contagem de caracteres da palavra do documento onde, se a palavra possuir de 1 a 13 caracteres ser√° feita a compara√ß√£o com a lista de <i>stopwords</i> que possuir a mesma quantidade de caracteres desta palavra e se houver mais que 13 caracteres, essa palavra n√£o se encaixa √†s <i>stopwords</i>, ent√£o ser√° uma compara√ß√£o a menos para ser feita.</li>
	
</ul>

---

### üîé L√≥gica do ranqueamento de documentos e do c√°lculo TF-IDF

Com a filtragem das _stopwords_ conclu√≠da √© poss√≠vel iniciar o algoritmo com foco no c√°lculo e ranqueamento do TF-IDF onde primeiramente ser√° tratada a pesquisa do usu√°rio que vai ser inserida em um arquivo chamado `phrasetosearch.txt` onde a partir disso ser√° chamada a fun√ß√£o <a href="#fun√ß√£o-read_phrase">_read_phrase_</a> (explicada melhor na aba <a href="#%EF%B8%8F-fun√ß√µes">Fun√ß√µes</a>), que vai receber como par√¢metro os arquivos de filtragem das <i>stopwords</i> e o arquivo contendo a pesquisa do usu√°rio, lendo ent√£o a frase de pesquisa e tratando-a, retirando pontua√ß√µes (utilizando a fun√ß√£o <a href="#fun√ß√£o-string_treatment">_string_treatment_</a>) e suas <i>stopwords</i> deixando ent√£o somente _strings_ que tem relev√¢ncia para a pesquisa evitando um falso positivo no processo de ranking. Feito isso, ser√° criada seis **listas din√¢micas** que correspondem aos seis documentos que ser√£o utilizados com base na pesquisa para o ranqueamento, onde a partir disso ser√° chamada a fun√ß√£o <a href="#fun√ß√£o-filter_documents">_filter_documents_</a> que vai receber como par√¢metro uma lista vazia (**document_x**) que ao final dessa fun√ß√£o vai ser uma lista do documento tratado, uma string (**doc_name**) que antes de ser passada como par√¢metro ir√° receber o nome do arquivo em que vai ser filtrado e as listas que possuem as filtragens de caracteres das _stopwords_, fazendo com que ent√£o o documento passado como par√¢metro seja filtrado retirando todas as suas _stopwords_ e colocando aquelas palavras que n√£o s√£o na lista (**document_x**) deixando apenas as palavras relevantes e ent√£o estruturando os documentos para o in√≠cio do c√°lculo `TF-IDF` e o ranqueamento. Ap√≥s ser feito esse tratamento dos documentos de busca uma nova sequ√™ncia de lista ser√° criada (listas **wordcounter_docx**) em que ser√£o usadas para serem passadas como par√¢metros para uma nova fun√ß√£o constru√≠da chamada <a href="#fun√ß√£o-fill_list_with_cont">_fill_list_with_cont_</a> onde recebe tamb√©m a lista do documento que foi tratada anteriormente e faz com que cada palavra dessa lista do documento de busca seja verificada e contada a cada vez que aparece nesse documento, inserindo essas informa√ß√µes em uma outra lista que possui em seu bloco um **contador** e uma **string** para mais a frente ser poss√≠vel utilizar esses dados para os c√°lculos juntamente com os dados da fun√ß√£o <a href="#fun√ß√£o-verify_how_many_times_seen">_verify_how_many_times_seen_</a> que vai ser chamada logo em seguida fazendo tamb√©m a contagem de vezes em que a palavra aparece mas com os par√¢metros diferentes sendo eles: lista da pesquisa do usu√°rio (**input**) e o documento de busca (**document_x**), ou seja, essa fun√ß√£o vai fazer com que seja feita a verifica√ß√£o de quantas vezes as palavras da pesquisa do usu√°rio vai aparecer no documento correspondente colocando um **contador** nessas palavras e armazenando no bloco **ContWordSeen** que possui um **contador** e uma **string** para que ao final de tudo seja poss√≠vel chamar a fun√ß√£o criada <a href="#fun√ß√£o-tf_idf_calc">_tf_idf_calc_</a> (explicada com mais detalhes no t√≥pico abaixo), que recebe como par√¢metro a lista de pesquisa (**input**) e todas as outras listas sendo elas **wordcounter_docx** e **document_x** onde vai ser feito o c√°lculo `TF-IDF` de cada documento utilizando os dados das listas passadas como par√¢metro, armazenando os valores do c√°lculo em um vetor do tipo (**_float_**) para melhor resultado, passando esses valores para um **vector** correspondente ao documento e assim ent√£o fazendo uma verifica√ß√£o de qual √© maior colocando-o na primeira posi√ß√£o para ao final entregar o resultado imprenso da maneira como √© visto a seguir:

<p align="center">
<img src="img/saida_ranqueamento.png" width="230px"/> 
</p>
<p align="center">
<i>Imagem 1: Sa√≠da do programa onde √© imprenso o ranking de relev√¢ncia dos documentos</i>
</p>

Levando em considera√ß√£o o resultado da imagem acima os documentos utilizados foram todos padr√µes passados pelo professor sendo a pesquisa a frase inserida no arquivo `phrasetosearch.txt`: _**'Em que a expans√£o do mercado influencia no fluxo de informa√ß√µes?'**_.  

---

## ‚öôÔ∏è Fun√ß√µes

O algoritmo TF-IDF constru√≠do pelo grupo √© composto por um total de 17 fun√ß√µes, sendo 5 dessas fun√ß√µes utilizadas para o tratamento de 4 `Estruturas de Dados do Tipo Lista Din√¢mica`, como por exemplo <i>inser√ß√µes, remo√ß√µes, impress√µes e verifica√ß√µes de espa√ßos</i> dessas **listas**. As demais fun√ß√µes foram pensadas para a constru√ß√£o e tratamento do algoritmo TF-IDF, compondo o <i>c√°lculo, implementa√ß√£o, tratamento de **stop words** e ranqueamento</i>, sendo elas:

---

<p align="center">
 <a href="#fun√ß√£o-tf_idf">Fun√ß√£o "tf_idf"</a> |
 <a href="#fun√ß√£o-read_phrase">Fun√ß√£o "read_phrase"</a> |
 <a href="#fun√ß√£o-check_if_stopword_final_cont">Fun√ß√£o "check_if_stopword_final_cont"</a> |
 <a href="#fun√ß√£o-filter_documents">Fun√ß√£o "filter_documents"</a> | 
 <a href="#fun√ß√£o-string_treatment">Fun√ß√£o "string_treatment"</a> |
 <a href="#fun√ß√£o-check_if_stopword">Fun√ß√£o "check_if_stopword"</a> | 
 <a href="#fun√ß√£o-fill_list_with_cont">Fun√ß√£o "fill_list_with_cont"</a> |
 <a href="#fun√ß√£o-verify_if_word_exist">Fun√ß√£o "verify_if_word_exist"</a> |
 <a href="#fun√ß√£o-verify_how_many_times_seen">Fun√ß√£o "verify_how_many_times_seen"</a> |
 <a href="#fun√ß√£o-tf_idf_calc">Fun√ß√£o "tf_idf_calc"</a> |
 <a href="#fun√ß√£o-find_word_cont">Fun√ß√£o "find_word_cont"</a>
</p>

---



### ‚Ä¢Fun√ß√£o **_read_phrase_**

A fun√ß√£o `read_phrase` recebe **phrasetosearch.txt**, um documento onde est√° a frase e/ou palavra de pesquisa do usu√°rio. Lendo esse documento e chamando outras fun√ß√µes para trat√°-lo, retirando stopwords e caracteres especiais com a ajuda de outras fun√ß√µes. Por fim, o documento de pesquisa est√° tratado somente com palavras que possui relev√¢ncia facilitanto assim o c√°lculo do tfidf.

```c++
	read_phrase(&input, "phrasetosearch.txt", &sw1, &sw2, &sw3, &sw4, &sw5, &sw6, &sw7, &sw8, &sw9, &sw10, &sw11, &sw12, &sw13);
```
_Representa√ß√£o 1: chamada da fun√ß√£o read_phrase_

### ‚Ä¢Fun√ß√£o **_check_if_stopword_final_cont_**

Assim como a fun√ß√£o `check_if_stopword`, essa fun√ß√£o verefica se as palavras s√£o stopwords recebendo como par√¢metro uma lista com stopwords, entretanto essa fun√ß√£o tem um contador para a quantidade de vezes que cada palavra aparece fazendo com que dessa forma, n√£o hajam palavras replicadas.

```c++
void check_if_stopword_final_cont(List *main_doc, List *sw, ContWordSeen aux) {
	Block *aux_block;

	aux_block = sw->first->prox;

	while (aux_block != NULL) {
		if (aux.word == aux_block -> data.word) {
			return;
		}

		aux_block = aux_block -> prox;
	}

	LInsertContWordSeen(main_doc, aux);
}
```
_Representa√ß√£o 1: implementa√ß√£o da fun√ß√£o check_if_stopword_final_cont_

```c++
	check_if_stopword_final_cont(doc, sw1, aux);
```
_Representa√ß√£o 2: chamada da fun√ß√£o para a lista de stopwords de um √∫nico caracter_

### ‚Ä¢Fun√ß√£o **_filter_documents_**

Esta fun√ß√£o tem como par√¢metro a cria√ß√£o de 14 listas, uma para o documento principal a ser comparado e as outras 13 para as *stopwords*, separando as *stopwords* pela quantidade de caracteres. O que esta fun√ß√£o faz √© bem simples, mas muito importante para a otimiza√ß√£o do algoritmo, a principal fun√ß√£o dela √© identificar as *stopwords* presentes em cada documento e em seguida remov√™-las gerando um novo documento sem as *stopswords*.

```c++
void filter_documents(List *doc, std::string doc_name, List *sw1, List *sw2, List *sw3, List *sw4, List *sw5, List *sw6, List *sw7, List *sw8, List *sw9, 
List *sw10, List *sw11, List *sw12, List *sw13)
```
Dentro da fun√ß√£o s√£o criados alguns vari√°veis para auxiliar na abertura e na leitura dos arquivos.
```c++
std::ifstream myfile;
	std::string line, auxiliar, auxiliar_2, delimiter = " ";
	Item aux;
	size_t pos = 0;
	int cont = 0;
```
Logo, ap√≥s abrirmos o arquivo principal, entramos em uma estrutura de repeti√ß√£o `while` e lemos linhas por linha deste arquivo, bem como salvamos na vari√°vel **aux** do tipo `Item`.
```c++
if (myfile.is_open()) {
		while(!myfile.eof()) {
			getline(myfile, line);
			aux.word = line;
```

Ap√≥s as linhas salvas, a fun√ß√£o entra em uma estrutura de repeti√ß√£o `While`, usamos um delimitador chamado **delimiter**, o qual identifica espa√ßos em branco na linha em que est√° sendo lida, apaga estes espa√ßos e salva as palavras separadas em uma vari√°vel chamada **auxliliar**. Em seguida, √© onde tratamos cada string e identificamos se ela √© uma palavra ou apenas um s√≠mbolo, chamando a vari√°vel `string_treatment` e passando como par√¢mentro a `string` **auxiliar**. As strings identificadas como palavras s√£o salvas na vari√°vel **auxiliar_2** e, logo ap√≥s, retornam para a vari√°vel `Item` **aux**.
```c++
while ((pos = line.find(delimiter)) != std::string::npos) {
				aux.word = (line.substr(0, pos));
				line.erase(0, pos + delimiter.size());
				auxiliar = aux.word;
				auxiliar_2 = string_treatment(auxiliar);
				aux.word = auxiliar_2;
```
Ainda dentro da estrutura `while` come√ßamos a comparar as palavra salvas com as *stop words* e removemos as palavras identificadas como *stopwords*, cada palavra √© comparada respectivamente com alguma *stopword* do memso tamanho. Assim, otimizando o tempo de execu√ß√£o do algoritmo. Ap√≥s isto, todas as palavras restantes s√£o salvas novamente em um arquivo principal, por√©m agora sem as *stopwords*.
```c++
if (aux.word.size() == 1) {
					check_if_stopword(doc, sw1, aux);
				} else if (aux.word.size() == 2) {
					check_if_stopword(doc, sw2, aux);
				} else if (aux.word.size() == 3) {
					check_if_stopword(doc, sw3, aux);
				} else if (aux.word.size() == 4) {
					check_if_stopword(doc, sw4, aux);
				} else if (aux.word.size() == 5) {
					check_if_stopword(doc, sw5, aux);
				} else if (aux.word.size() == 6) {
					check_if_stopword(doc, sw6, aux);
				} else if (aux.word.size() == 7) {
					check_if_stopword(doc, sw7, aux);
				} else if (aux.word.size() == 8) {
					check_if_stopword(doc, sw8, aux);
				} else if (aux.word.size() == 9) {
					check_if_stopword(doc, sw9, aux);
				} else if (aux.word.size() == 10) {
					check_if_stopword(doc, sw10, aux);
				} else if (aux.word.size() == 11) {
					check_if_stopword(doc, sw11, aux);
				} else if (aux.word.size() == 12) {
					check_if_stopword(doc, sw12, aux);
				} else if (aux.word.size() == 13) {
					check_if_stopword(doc, sw13, aux);
				} else {
					LInsert(doc, aux);
				}

```
Caso o arquivo n√£o atenda a nenhum par√¢metro, ser√° printado na tela uma mensagem ao usu√°rio que o arquivo n√£o p√¥de ser aberto.
```c++
else {
		std::cout << "nao abriu";
	}
```

### ‚Ä¢Fun√ß√£o **_string_treatment_**

A fun√ß√£o `string_treatment` retira caracteres indesejados em string como pontos de acentua√ß√£o, n√∫meros e tamb√©m deixando todas as letra em min√∫sculo. Esssa fun√ß√£o recebe como par√¢metro uma string que retorna a mesam tratada facilitando assim a pesquisa nos documentos.

```c++
	std::string string_treatment(std::string s) {
	int size = s.size();
	std::string aux;

	for (int i = 0; i < size; i++) {
		if (s[i] != '.' && s[i]!= ',' && s[i] != ':' && s[i] != ';' && s[i] != '?' && s[i] != '!' && s[i] != '(' && s[i] != ')' && s[i] != '[' && s[i] != ']' && s[i] != '{'
			&& s[i] != '}' && s[i] != '+'&& s[i] != '=' && s[i] != '-' && s[i] != '*' && s[i] != '/' && s[i] != '%' && !isdigit(s[i])) {
			s[i] = tolower(s[i]);
            aux += s[i];
		}
	}
 
	return aux;
}
```
_Representa√ß√£o 1: implementa√ß√£o da fun√ß√£o string_treatment_

```c++
	auxiliar_2 = string_treatment(auxiliar);
```
_Representa√ß√£o 2: chamada da fun√ß√£o string_treatment_

### ‚Ä¢Fun√ß√£o **_check_if_stopword_**

Essa fun√ß√£o recebe como par√¢metro uma lista de stopwords com todas as stopwords pr√©-colocadas para serem deprezadas dos documentos verificando assim se as palavras dos documentos est√£o presente na lista de stopwords. 

```c++ void check_if_stopword(List *main_doc, List *sw, Item aux) {
	void check_if_stopword(List *main_doc, List *sw, Item aux) {
	Block *aux_block;

	aux_block = sw->first->prox;

	while (aux_block != NULL) {
		if (aux.word == aux_block -> data.word) {
			return;
		}

		aux_block = aux_block -> prox;
	}

	LInsert(main_doc, aux);
}
```
_Representa√ß√£o 1: implementa√ß√£o da fun√ß√£o check_if_stopword_

```c++
	check_if_stopword(doc, sw1, aux);
```
_Representa√ß√£o 2: chamanda da fun√ß√£o para a lista de stopwords com um √∫nico caracter_

### ‚Ä¢Fun√ß√£o **_fill_list_with_cont_**

Essa fun√ß√£o introduz a primeira parte do ranqueamento dos documentos, fazendo com que seja contado, com um contador **cont** dentro da fun√ß√£o, a quantidade de vezes em que as palavras v√£o aparecer naquele documento. A fun√ß√£o recebe como par√¢metro duas listas, a lista em que cont√©m a filtragem do documento em que vai ser feita o ranqueamento das palavras e uma outra lista vazia que vai ser preenchida dentro da fun√ß√£o com a lista `WordCounter` como na representa√ß√£o abaixo:

```c++
    void fill_list_with_cont(List *document, List *wordcount);
```
_Representa√ß√£o 1: chamada da fun√ß√£o _fill_list_with_cont__

Ap√≥s ser feita a chamada da fun√ß√£o ela inicia com a chamada da lista `WordCounter` que possui em seu bloco uma string e um contador onde vai auxiliar o ranqueamento das palavras com a quantidade de vezes em que ela apareceu nesse contador, com isso vai ser iniciado uma estrutura de repeti√ß√£o __*while*__ em que vai ser repetida enquanto o documento principal n√£o terminar e dentro dessa estrutura uma vari√°vel auxiliar de string **aux_str** vai receber palavra por palavra desse documento a cada vez que a estrutura for repetida fazendo a verifica√ß√£o com uma estrutura de decis√£o `IF` verificando caso palavra n√£o exista com a fun√ß√£o <a href="#fun√ß√£o-verify_if_word_exist">_verify_if_word_exist_</a> (explicada melhor no t√≥pico abaixo), se n√£o existir o programa vai entrar nessa estrutura e adicionar essa palavra que n√£o existe na lista `WordCounter` com seu contador recebendo o n√∫mero 1 de acordo com a representa√ß√£o abaixo:

```c++
    if (!verify_if_word_exist(wordcount, aux_str)) {
        aux_insert.word = aux_main_document->data.word;
        aux_insert.contador = 1;
        LInsertWordCounter(wordcount, aux_insert);
    }
```
_Representa√ß√£o 2: inser√ß√£o da palavra n√£o existente na lista WordCounter_

Ao sair dessa estrutura de decis√£o a vari√°vel **cont** vai acrescentar mais uma unidade em seu valor para que no final seja contabilizada a quantidade de palavras em que vai aparecer no documento analisado pela fun√ß√£o adicionando esse valor ao bloco `Contador`.


### ‚Ä¢Fun√ß√£o **_find_word_cont_**

A fun√ß√£o _find__cont_ foi constru√≠da pensando no aux√≠lio do c√°lculo `TF-IDF` onde ela retorna um tipo **int** sendo o n√∫mero de ocorr√™ncias presente na fun√ß√£o <a href="#fun√ß√£o-tf_idf_calc">_tf_idf_calc_</a>, que obtido com base nos par√¢metros passados na chamada da fun√ß√£o que consiste em uma lista com as palavras contadas de determinado documento (**wordcounter_doc1**) e em string que √© passada a partir do bloco da lista **input** (lista que possui a pesquisa do usu√°rio) como √© poss√≠vel ver na representa√ß√£o abaixo:

```c++
    int find_word_cont(List *wordcounter, std::string to_find);
```
_Representa√ß√£o 1: chamada da fun√ß√£o _find_word_cont__

Ap√≥s ser feita essa chamada a fun√ß√£o introduzir√° declarando um bloco auxiliar <b>*aux</b> onde vai receber a primeira posi√ß√£o da lista que cont√©m as palavras contados do documento passado como par√¢metro (lista **wordcounter_docx**) e atrav√©s de uma estrutura de repeti√ß√£o `WHILE` vai percorrer essa lista at√© o final e a cada posi√ß√£o percorrida vai ser feita uma verifica√ß√£o a partir de uma estrutura de decis√£o `IF` verificando se a string presente em determinada posi√ß√£o da lista percorrida √© igual a string passada como par√¢metro e caso essa verifica√ß√£o seja verdadeira a fun√ß√£o ir√° retornar o contador da string da lista **wordcounter_docx**, visto que isso vai auxiliar no c√°lculo como citado anteriormente pois ao retornar para a fun√ß√£o <a href="#fun√ß√£o-tf_idf_calc">_tf_idf_calc_</a> esse contador, vai ser poss√≠vel ser feitos os c√°lculos com os valores obtidos de quantas vezes a palavra presente na pesquisa apareceu em determinado documento.



### ‚Ä¢Fun√ß√£o **_verify_if_word_exist_**

Essa fun√ß√£o tem como objetivo apenas de ser utilizada na estrutura de decis√£o `IF` fun√ß√£o <a href="#fun√ß√£o-fill_list_with_cont">_fill_list_with_cont_</a> como verifica√ß√£o de existencia da palavra passada como par√¢metro (**aux_str**) em conjunto com uma lista de palavras com um contador (**wordcount**) como na representa√ß√£o abaixo:

```c++
    bool verify_if_word_exist(List *wordcount, string word);
```
_Representa√ß√£o 1: chamada da fun√ß√£o _verify_if_word_exist__

Dentro dessa fun√ß√£o vai ser chamado um bloco auxiliar ***aux** que vai receber a primeira posi√ß√£o da lista `wordcount` para que seja poss√≠vel percorre-la inteira dentro da estrutura de repeti√ß√£o __<i>while</i>__ at√© o final onde a cada posi√ß√£o percorrida vai ser feita uma verifica√ß√£o com a estrutura de decis√£o `IF` se a palavra passada como par√¢metro j√° est√° dentro da lista, caso n√£o estiver a fun√ß√£o vai retornar o tipo booleano <b>false</b>, caso possua a palavra dentro da lista `wordcount` ser√° acrescentando mais uma unidade no valor da vari√°vel <b>contador</b> do bloco daquela palavra possibilitando ent√£o o ranqueamento de palavras dentro do documento pois com isso ser√° poss√≠vel verificar a quantidade de vezes em que as palavras est√£o dentro dos documentos que v√£o ser feito o ranqueamento, retornando ent√£o no final o tipo booleano <b>true</b>.


### ‚Ä¢Fun√ß√£o **_verify_how_many_times_seen_**

Essa fun√ß√£o foi constru√≠da com objetivo de verificar quantas vezes uma palavra pertencente a pesquisa do usu√°rio aparece no documento passado como par√¢metro (**document_x**) recebendo tamb√©m a lista que cont√©m as palavras da pesquisa como par√¢metro (lista **input**) como na representa√ß√£o a seguir

```c++
    void verify_how_many_times_seen(List *input, List *document);
```
_Representa√ß√£o 1: chamada da fun√ß√£o _verify_how_many_times_seen__

A fun√ß√£o come√ßa com a declara√ß√£o de dois blocos auxiliares das listas sendo eles <b>*aux_input</b> e <b>*aux_document</b> onde a partir disso vai ser chamado duas estruturas de repeti√ß√£o `WHILE`, uma que vai percorrer a lista **input** com a ajuda do bloco auxiliar e outra que vai percorrer a lista **document** at√© o final e a cada posi√ß√£o percorrida vai ser feita a verifica√ß√£o, com uma estrutura de decis√£o `IF`, se a palavra pertencente a posi√ß√£o da lista **document**, ou seja, do documento de busca √© igual a palavra da posi√ß√£o do documento que possui a pesquisa do usu√°rio. Caso essa verifica√ß√£o prossiga vai ser acrescentado mais uma unidade no valor do contador possuente do bloco da pesquisa do usu√°rio e ap√≥s isso √© colocada a posi√ß√£o do **aux_document** (vari√°vel que ajuda a percorrer a lista) no final da lista para que seja poss√≠vel come√ßar uma outra verifica√ß√£o de outra posi√ß√£o da lista **input** at√© o final dessa lista. 



### ‚Ä¢Fun√ß√£o **_tf_idf_calc_**

A pr√≥xima fun√ß√£o talvez seja a mais importante do algoritmo, ele tem como objetivo fazer o c√°lculo do TF-IDF e retornar os arquivos mais relevantes de acordo com a pesquisa feita pelo usu√°rio.

A fun√ß√£o recebe como par√¢metro 13 estruturas do tipo lista, sendo 1(input) para salvar o termo pesquisado pelo usu√°rio, 6(wordcouter_doc...) que ser√£o utilizados no c√°lculo do TF para salvar o n√∫mero que cada termo aparece em cada documento, e 6(document_...) para salvar os documentos a serem analizados.

```c++
void tf_idf_calc(List *input, List *wordcounter_doc1, List *wordcounter_doc2, List *wordcounter_doc3, List *wordcounter_doc4, List *wordcounter_doc5, List *wordcounter_doc6,
List *document_1, List *document_2, List *document_3, List *document_4, List *document_5, List *document_6)

```

Na primeira intera√ß√£o do c√≥digo s√£o salvos em um vector valores do tipo `string` para que servir√£o para definir o ranking dos documentos, ap√≥s isso uma estrutura de repeti√ß√£o `for` define os valores do vetor `final_tfidf[i]` para zero.

```c++
	ranking.push_back("1st Document");
	ranking.push_back("2nd Document");
	ranking.push_back("3rd Document");
	ranking.push_back("4th Document");
	ranking.push_back("5th Document");
	ranking.push_back("6th Document");

	for (i = 0; i < 6; i++) {
		final_tfidf[i] = 0;
	}
 ```

Calculo do IDF:

A fun√ß√£o come√ßa a calcular o IDF, chamando uma estrutura de decis√£o `while`, que deve se repetir enquanto o valor da vari√°vel `aux_input` for diferente de **NULL**. Dentro desta estrutura, entramos em uma estrutura de decis√£o `if`, onde se o valor do termo por documento for diferente de zero o algoritmo entra nesta estrutura de decis√£o e calcula o IDF do termo em quest√£o, se a condi√ß√£o n√£o for atendida significa que o termo n√£o aparece no documento. Logo, seu IDF sera igual a zero.

```c++
while (aux_input != NULL) {
		i = 0;

		if (aux_input -> cont_all_documents.contador != 0) {
			idf = log10(6 / aux_input->cont_all_documents.contador);
		} else {
			idf = 0;
		}
```

Calculo do tf:

Ap√≥s calcular o IDF a fun√ß√£o inicia o c√°lculo do TF, primeiramente, s√£o atribu√≠dos a uma vari√°vel **ocurrences** o valor que conta na fun√ß√£o `find_word_cont`, que nada mais √© a quantidade de vezes que o termo apareceu em um documento espec√≠fico. Logo ap√≥s, s√£o salvos na vari√°vel **total** o total de palavras que existem no documento. Ap√≥s todas a vari√°veis necess√°rias serem setadas com os devidos valores o algoritmo chama uma estrutura de decis√£o `if`, verificando se o termo analisado aparece no documento em quest√£o. Se o valor da vari√°vel "occurrencs" for "0", logo o *TF* deste termo tamb√©m √© zero, caso contr√°rio o algoritmo entra em uma estrutura `else`, fazendo o c√°lculo do *TF*. Nesse sentido, ao sair desta estrutura √© feito o c√°lculo do *TFxIDF*, o valor √© atribu√≠do a uma posi√ßao do vetor "final_tfidf[i]". Esta estrutura se repete "6" vezes, uma vez para cada arquivo principal passsado.
 
```C++
occurrences = find_word_cont(wordcounter_doc1, aux_input->cont_all_documents.word);
		total = document_1 ->first->prox->cont.total_words;
		if (occurrences == 0) {
			tf = 0;
		} else {
			tf = (float)occurrences / (float)total;
		}
		final_tfidf[i] += (tf*idf);
		i++;

		occurrences = find_word_cont(wordcounter_doc2, aux_input->cont_all_documents.word);
		total = document_2 ->first->prox->cont.total_words;
		if (occurrences == 0) {
			tf = 0;
		} else {
			tf = (float)occurrences / (float)total;
		}
		final_tfidf[i] += (tf*idf);
		i++;

		occurrences = find_word_cont(wordcounter_doc3, aux_input->cont_all_documents.word);
		total = document_3 ->first->prox->cont.total_words;
		if (occurrences == 0) {
			tf = 0;
		} else {
			tf = (float)occurrences / (float)total;
		}
		final_tfidf[i] += (tf*idf);
		i++;

		occurrences = find_word_cont(wordcounter_doc4, aux_input->cont_all_documents.word);
		total = document_4 ->first->prox->cont.total_words;
		if (occurrences == 0) {
			tf = 0;
		} else {
			tf = (float)occurrences / (float)total;
		}
		final_tfidf[i] += (tf*idf);
		i++;

		occurrences = find_word_cont(wordcounter_doc5, aux_input->cont_all_documents.word);
		total = document_5 ->first->prox->cont.total_words;
		if (occurrences == 0) {
			tf = 0;
		} else {
			tf = (float)occurrences / (float)total;
		}
		final_tfidf[i] += (tf*idf);
		i++;

		occurrences = find_word_cont(wordcounter_doc6, aux_input->cont_all_documents.word);
		total = document_6 ->first->prox->cont.total_words;
		if (occurrences == 0) {
			tf = 0;
		} else {
			tf = (float)occurrences / (float)total;
		}
		final_tfidf[i] += (tf*idf);
		i++;
```


Por √∫ltimo, a fun√ß√£o entra em duas estruturas de repeti√ß√£o `for` e em uma estrutura de decis√£o `if`, que tem como par√¢metro de compara√ß√£o o c√°lculo final do *TF-IDF*. Estas √∫ltimas estruturas do c√≥digo tem como fun√ß√£o ordernar de forma descresente os documentos analisados, fazendo assim um ranking de documentos mais relevantes de acordo com o *TF-IDF*.

```c++
for (i = 0; i < 6; i++) {
		for (int j = i + 1; j < 6; j++) {
			if (final_tfidf[i] < final_tfidf[j]) {
				auxiliar = final_tfidf[i]; aux = ranking[i];
				final_tfidf[i] = final_tfidf[j]; ranking[i] = ranking[j];
				final_tfidf[j] = auxiliar; ranking[j] = aux;
			}
		}
	}

	std::cout << std::endl << std::endl;
	for (i = 0; i < 6; i++) {
		std::cout << ranking[i] << std::endl; 
	}
}
```
---



### ‚Ä¢Fun√ß√£o **_tf_idf_**

Esta √© utiliza como fun√ß√£o principal, seu objetivo √© executar todas as outras fun√ß√µes secund√°rias e registrar o tempo de execu√ß√£o de cada fun√ß√£o.  

```c++
void tf_idf() {
```

## üì∑ Representa√ß√£o gr√°fica

A representa√ß√£o abaixo demonstra detalhadamente cada etapa em que o algoritmo foi pensado e funciona utilizando como exemplo a frase de pesquisa _**'Em que a expans√£o do mercado influencia no fluxo de informa√ß√µes?'**_ buscando os seis documentos padr√µes fornecidos pelo professor [Michel Pires da Silva](http://lattes.cnpq.br/1449902596670082). 

<div align="center">
  <a href="https://www.youtube.com/watch?v=bJOeznIbGag"><img src="https://yt-embed.herokuapp.com/embed?v=bJOeznIbGag" alt="Anima√ß√£o TF-IDF" width="800px"></a>
</div>

_Representa√ß√£o 1: V√≠deo contendo detalhadamente etapas do algoritmo_

---

## üî© Execu√ß√£o de testes

### Tempo de execu√ß√£o

O tempo de execu√ß√£o do algoritmo `TF-IDF` foi medido utilizando da biblioteca **time.h** que desenvolve a leitura do rel√≥gio em segundos ao utilizar sua fun√ß√£o _clock_ que devolve o tempo de CPU decorrido desde o in√≠cio da execu√ß√£o do programa, onde o tempo √© medido em ciclos do rel√≥gio interno como no exemplo de medi√ß√£o abaixo:

```c++
    size_t t;
    t = clock();
    tf_idf(); //Chamada da fun√ß√£o que implementa o algoritmo TF-IDF
    t = clock() - t;

    cout << "\nTempo total: " << float(t)/CLOCKS_PER_SEC << " segundos" << std::endl << std::endl;
```
_Representa√ß√£o 1: Exemplo de implementa√ß√£o da fun√ß√£o **time.h**_

<p align="left">
<img src="img/saida_ex_tempo.png" width="350px"/> 
</p>

_Imagem 1: Exemplo de sa√≠da do tempo de execu√ß√£o da implementa√ß√£o acima_

Com a aplica√ß√£o dessa fun√ß√£o ent√£o foi poss√≠vel medir o tempo de execu√ß√£o das 5 diferentes etapas do programa at√© chegar ao seu final onde efetua toda a proposta com √™xito, sendo essas etapas <b><i>implementa√ß√£o das stopwords</b></i>, <b><i>leitura e filtragem dos documentos</b></i>, <b><i>contagem de palavra por palavra</b></i>, <b><i>verifica√ß√£o da contagem total de cada palavra presente nos documentos</b></i> e o<b><i> c√°lculo TF-IDF</b></i>, segue ent√£o a tabela abaixo onde possibilita visualizar a quantidade de vezes medida e a m√©dia aritm√©tica entre as mesmas
 
_Tabela 1: Resultado dos testes de tempo de execu√ß√£o de cada etapa do algoritmo_
| Etapas | Teste 1 | Teste 2 | Teste 3 | Teste 4 | Teste 5 |                                              
|------------------|------------|------------|------------|------------|------------|
|  <b>Etapa 1</B>  | 7.4e-05 s  | 8.1e-05 s  | 7.4e-05 s  | 7.9e-05 s  | 8.2e-05 s  |                                
|  <b>Etapa 2</B>  | 0,235741 s | 0.231393 s | 0.224697 s | 0.225507 s | 0.221642 s |               
|  <b>Etapa 3</B>  | 0.459084 s | 0.461116 s | 0.455663 s | 0.454371 s | 0.440808 s |
|  <b>Etapa 4</B>  | 0.004293 s | 0.004784 s | 0.004476 s | 0.004548 s | 0.004129 s |
|  <b>Etapa 5</B>  | 0.000155 s | 0.000171 s | 0.000157 s | 0.000151 s | 0.000121 s |
|  <b>Total</B>    | 0.699649 s | 0.697839 s | 0.685403 s | 0.684977 s | 0.667042 s |

    M√©dia Aritm√©tica das medi√ß√µes feitas: 0.686982 segundos

**_Observa√ß√£o:_** Todos os testes foram feitos em um computador com o sistema operacional Windows, utilizando _WSL (Windows Subsystem for Linux)_ para compila√ß√£o, que possui um processador _AMD Ryzen 5 1600 Six-Core Processor 3.20 GHz_ com _16,0 GB de RAM DDR4_ utilizando uma frase padr√£o de pesquisa inserida no arquivo `phrasetosearch.txt`, sendo ela _**'Em que a expans√£o do mercado influencia no fluxo de informa√ß√µes?'**_.

A figura abaixo consegue demonstrar a sa√≠da do programa onde fornece os tempos de execu√ß√£o em cada etapa:

<p align="center">
<img src="img/sa√≠da_calculotempo.png" width="800px"/> 
</p>

_Imagem 2: Sa√≠da do programa onde imprime os resultados dos testes de tempo de execu√ß√£o de cada etapa do algoritmo_

### C√°lculo do tempo de execu√ß√£o total de cada integrante

Em conjunto com o grupo em que foi respons√°vel pela cria√ß√£o do algoritmo foi organizado uma tabela possuindo os dados de seus **processadores**, **mem√≥ria RAM** e **Sistema Operacional** de cada integrante do grupo (um total de 9), sendo esses hardwares que possuem relev√¢ncia para a diferen√ßa do c√°lculo de tempo, onde cada um compilou e executou o c√≥digo em sua m√°quina aferindo o tempo de execu√ß√£o em um total de 5 vezes tornando poss√≠vel visualizar com um menor desvio padr√£o do resultado possibilitando na cria√ß√£o da tabela abaixo:

| Nome | Processador | M√©moria (GB) | Sistema Operacional |  Tempo 1 (s) |  Tempo 2 (s) |  Tempo 3 (s) |  Tempo 4 (s) |  Tempo 5 (s) |  M√©dia Aritm√©tica (s) |                                            
|------------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|
| <b>Caio</b> | Processador | M√©moria (GB) | Sistema Operacional |  Tempo 1 (s) |  Tempo 2 (s) |  Tempo 3 (s) |  Tempo 4 (s) |  Tempo 5 (s) |  M√©dia Aritm√©tica (s) |                                
| <b>Felipe</b> | Processador | M√©moria (GB) | Sistema Operacional |  Tempo 1 (s) |  Tempo 2 (s) |  Tempo 3 (s) |  Tempo 4 (s) |  Tempo 5 (s) |  M√©dia Aritm√©tica (s) |               
| <b>Henrique</b> | Intel i7-4790K | 16 | Windows 10 (WSL) |  0,695625 |  0,695431 |  0,685270 |  0,684731 |  0,679782 |  0,688168 |
| <b>Jo√£o Marcelo</b> | Intel i5-8265U | 8 | Ubuntu 20.04.4  |  1.34769 |  1.36259 |  1.38506 |  1.38253 |  1.34472 |  1,364518  |
| <b>Jo√£o Pedro | Processador | M√©moria (GB) | Sistema Operacional |  Tempo 1 (s) |  Tempo 2 (s) |  Tempo 3 (s) |  Tempo 4 (s) |  Tempo 5 (s) |  M√©dia Aritm√©tica (s) |
| <b>Livia</b> | Processador | M√©moria (GB) | Sistema Operacional |  Tempo 1 (s) |  Tempo 2 (s) |  Tempo 3 (s) |  Tempo 4 (s) |  Tempo 5 (s) |  M√©dia Aritm√©tica (s) |
| <b>Lucas</b> | Intel i7-6700K | 16GB | UBUNTU 20.04 |  0.509106 |  0.51278 |  0.513569 |  0.509033 |  0.517417 |  0.512381 |
| <b>Pedro Louback</b> | AMD Ryzen 5 1600 | 16 | Windows 10 (WSL) |  0,662935 |  0,679511 |  0,676082 |  0,680472 |  0,678130 |  0,675426 |
| <b>Pedro Pinheiro</b> | Intel i7-9750H | 8 | Windows 11 (WSL) |  0.571197 |  0.584476 |  0.580301 |  0.574252 |  0.578098 |  0.5776648 |

‚Ä¢ Obtendo ent√£o a M√©dia Aritm√©tica de todas as aferi√ß√µes:

	M√©dia Aritm√©tica: 0,6265454 segundos

---

## üìö Bibliotecas

<p>Para o funcionamento do programa, √© necess√°rio incluir as seguintes bibliotecas: 
<ul>
    <li><code>#include 'iostream'</code></li>
    <li><code>#include 'time.h'</code></li>
    <li><code>#include 'unistd.h'</code></li>
    <li><code>#include 'cmath'</code></li>
    <li><code>#include 'fstream'</code></li>
    <li><code>#include 'string'</code></li>
    <li><code>#include 'vector'</code></li>
</ul>

---

## üîß Compila√ß√£o e Execu√ß√£o

O programa feito de acordo com a proposta possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. Para tanto, temos as seguintes diretrizes de execu√ß√£o:


| Comando                |  Fun√ß√£o                                                                                           |                     
| -----------------------| ------------------------------------------------------------------------------------------------- |
|  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
|  `make`                | Executa a compila√ß√£o do programa utilizando o g++, e o resultado vai para a pasta build           |
|  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o             


---

## ‚úíÔ∏è Autores

Projeto elaborado por [Caio Fernando Dias](https://github.com/Caio-Fernando-Dias), [Felipe Coelho de Oliveira Campos](https://github.com/fco3lho), [Henrique Souza Fagundes](https://github.com/ohenriquesouza), [Jo√£o Marcelo Gon√ßalves Lisboa](https://github.com/joaojmgl), [Jo√£o Pedro Martins Esp√≠ndola](https://github.com/JoaoMEspindola?tab=repositories), [Livia Gon√ßalves](https://github.com/Livia-Goncalves-01), [Lucas Farinelli Crivellari de Pinho](https://github.com/farinellizin), [Pedro Henrique Louback Campos](https://github.com/PedroLouback) e [Pedro Pinheiro de Siqueira](https://github.com/ppinheirosiqueira) 

Alunos da mat√©ria de Arquitetura e Estruturas de Dados 1 do curso de `Engenharia da Computa√ß√£o` no [CEFET-MG](https://www.cefetmg.br)

